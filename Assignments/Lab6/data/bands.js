// I pledge my honor that I have abided by the Stevens Honor System.

// This data file should export all functions using the ES6 standard as shown in the lecture code

import {
  oIDChecker,
  idToOID,
  areObjectsEqual,
  bandCreateError,
  bandUpdateError,
} from "../helpers.js";
import { ObjectId } from "mongodb";
import { bands } from "../config/mongoCollections.js";

// taken from lab 4
export const create = async (
  // id, // generated by mongo
  name, // string
  genre, // array of strings. Must have atleast 1 string
  website, // string; must start with "http://www" and end with ".com". Must have *5* characters between these (http://abcde.com or http://12345.com)
  recordCompany, // string
  groupMembers, // array of strings. Must have atleast 1 string
  yearBandWasFormed // number; throw an error if it is less than 1900 or greater than current year 2023 (wonder if I can make this dynamic rather than hardcode the end date)
) => {
  // since we need the error handling in the routes, I made this a function
  let good = await bandCreateError(
    name,
    genre,
    website,
    recordCompany,
    groupMembers,
    yearBandWasFormed,
    "data"
  );

  name = good[0];
  genre = good[1];
  website = good[2];
  recordCompany = good[3];
  groupMembers = good[4];
  yearBandWasFormed = good[5];

  // now the actual problem
  let newBand = {
    name: name,
    genre: genre,
    website: website,
    recordCompany: recordCompany,
    groupMembers: groupMembers,
    yearBandWasFormed: yearBandWasFormed,
    albums: [],
    overallRating: 0,
  };

  const bandCollection = await bands();
  const newData = await bandCollection.insertOne(newBand);

  if (!newData.acknowledged || !newData.insertedId) {
    throw new Error("unable to add provided band");
  }

  const newId = newData.insertedId.toString();
  const addedBand = await bandCollection.findOne({ _id: new ObjectId(newId) });

  addedBand._id = addedBand._id.toString();

  return addedBand;
};

// taken from lab 4
export const getAll = async () => {
  const bandCollection = await bands();

  let bandData = await bandCollection.find({}).toArray();

  if (bandData.length > 0) {
    for (let i = 0; i < bandData.length; i++) {
      bandData[i]._id = bandData[i]._id.toString();
    }
  }

  return bandData;
};

// taken from lab 4
export const get = async (id) => {
  let oID = idToOID(id);

  const bandCollection = await bands();
  const band = await bandCollection.findOne({ _id: oID });

  if (band == null) {
    throw new Error("there is no band that matches the provided ID");
  }

  band._id = band._id.toString();

  if (band.albums.length > 0) {
    for (let i = 0; i < band.albums.length; i++) {
      band.albums[i]._id = band.albums[i]._id.toString();
    }
  }

  return band;
};

// taken from lab 4
export const remove = async (id) => {
  let oID = idToOID(id);

  const bandCollection = await bands();
  const band = await bandCollection.findOne({ _id: oID });

  if (band == null) {
    throw new Error("there is no band that matches the provided ID");
  }

  const deleteBand = await bandCollection.findOneAndDelete({ _id: oID });

  // console.log(deleteBand)

  if (deleteBand.lastErrorObject.n === 0) {
    throw new Error("unable to delete band with the given ID");
  }

  return `${band.name} has been successfully deleted!`;
};

// mostly taken from lab 4
export const update = async (
  id,
  name,
  genre,
  website,
  recordCompany,
  groupMembers,
  yearBandWasFormed
) => {
  // since we need the error handling in the routes, I made this a function
  let good = await bandUpdateError(
    id,
    name,
    genre,
    website,
    recordCompany,
    groupMembers,
    yearBandWasFormed
  );

  id = good[0];
  name = good[1];
  genre = good[2];
  website = good[3];
  recordCompany = good[4];
  groupMembers = good[5];
  yearBandWasFormed = good[6];

  let oID = good[7];
  let bandCollection = good[8];
  let band = good[9];

  // now the actual problem
  let bandAlbums = band.albums;
  let bandOverallRating = band.overallRating;

  let updatedBandInfo = {
    _id: band._id,
    name: name,
    genre: genre,
    website: website,
    recordCompany: recordCompany,
    groupMembers: groupMembers,
    yearBandWasFormed: yearBandWasFormed,
    albums: bandAlbums,
    overallRating: bandOverallRating,
  };

  if (areObjectsEqual(band, updatedBandInfo)) {
    throw new Error(
      "unable to update band as the information given already matches what is in the database"
    );
  }

  const updatedBand = await bandCollection.findOneAndUpdate(
    { _id: oID },
    { $set: updatedBandInfo },
    { returnDocument: "after" }
  );

  if (updatedBand.lastErrorObject.n === 0) {
    throw new Error("unable to update band with the given ID");
  }

  const addedBand = await bandCollection.findOne({
    _id: new ObjectId(band._id),
  });

  addedBand._id = addedBand._id.toString();
  if (addedBand.albums.length > 0) {
    for (let i = 0; i < addedBand.albums.length; i++) {
      addedBand.albums[i]._id = addedBand.albums[i]._id.toString();
    }
  }

  return addedBand;
};

// console.log(
//   await create(
//     "Black Sabbath",
//     ["Heavy Metal"],
//     "http://wWw.blacksabbath.COM",
//     "Warner Records",
//     ["Ozzy Osbourne", "Bill Ward", "Geezer Butler", "Tony Iommi"],
//     1968
//   )
// );

// console.log(
//   await create(
//     "Pink Floyd",
//     ["Progressive Rock", "Psychedelic rock", "Classic Rock"],
//     "http://www.pinkfloyd.com",
//     "EMI",
//     [
//       "Roger Waters",
//       "David Gilmour",
//       "Nick Mason",
//       "Richard Wright",
//       "Sid Barrett",
//     ],
//     1965
//   )
// );

// console.log(
//   await update(
//     "640bae5de7cc0f54c8b99739",
//     "nameWO-_-W__sw223",
//     ["g1, g2"],
//     "http://www.testing.com",
//     "Company",
//     ["Guy1", "Guy2"],
//     2001
//   )
// );

// console.log(await get("640bae5de7cc0f54c8b99739"));
